#
# genplayer.pl - generate video player code
#
# WARNING WARNING WARNING:
#	"or a,0" is not safe padding; some code does need flags.
#	But gap_look is OK since we don't pad.
#	And gap_skip works because only nops are ever consumed for padding.

require 'z80.pl';

#            x   I   II   III   4a     4b     4c
#            x  tv1  tv2  tv3   tv4    tv5    tv6
#            -  ---  ---  ---  -----  -----  -----
@quantum = ( 0, 124,   0, 134,     0,     0,   256 );
@m1wait  = ( 0,   0,   0,   0,     2,     1,     0 );
@fhdwait = ( 0,   1,   0,   1,     3,     3,     3 );
@vidwait = ( 0,   0,   0,   0, 2.375, 2.375, 2.375 );
@speed   = ( 0, 112,   0, 128,   256,   256,   256 );

@ARGV == 2 || die "usage: genplayer.pl host# format#\n";

$host = $ARGV[0]; # Model playing back video
$format = $ARGV[1]; # Model video targeted for.

$host >= 1 && $host <=6 || die "genplayer: invalid host number '$host'.\n";
$format >= 1 && $format <= 6 || die "genplayer: invalid format number '$format'.\n";

$quantum[$format] || die "genplayer: video format '$format' not defined.\n";
$host >= $format || die "genplayer: host can't play formats bigger than itself.\n";

$quantum = int($quantum[$format] * $speed[$host] / $speed[$format] + 0.5);
$vidwait = $vidwait[$host];
$m1wait = $m1wait[$host];

if ($host == 6 && $format == 6) {
	die "Need to implement format 6 player generation.\n";
}

$var{'f_data'} = 0xc2;
$regval{'c'} = 0xc2; # f_data
$wait{0xc2} = $fhdwait[$host];

$gfx = q{
	ld	a,l
	exx
4	ini
	exx
	in	a,(f_data)
	ld	h,a
};

$home = q{
	ld	a,l
	exx
	in	l,(c)
	in	h,(c)
	sub	(hl)
	ret	c
	in	l,(c)
	in	h,(c)
	exx
	in	a,(f_data)
	ld	h,a
};

$aud = q{
	ld	a,l
	exx
	ex	de,hl
3	ini
	ex	de,hl
	exx
	in	a,(f_data)
	ld	h,a
};

$tail = q{
	out	(c),b
	jp	(hl)
};

$snd_off = q{
	out	(c),l
};

$exx_snd_off = q{
	out	(255),a
};

#
# The branches to "found" look the same, but end up being different due to
# padding.
# 
$gap_look = q{
	in	a,(f_data)
	cp	d
	jr	z,found
	in	a,(f_data)
	cp	d
	jr	z,found
	in	a,(f_data)
	cp	d
	jr	z,found
	dec	e
	ld	a,(de)
	ld	h,a
};

$gap_snd_off = $snd_off;
$exx_gap_snd_off = $snd_off;
$gap_tail = $tail;

# No dynamic padding of gap_look so "found" cases have extra time.
# Note that if you push all the way out to a quantum of 135 or so
# then there is enough slack that a little dynamic padding can occur
# in gap_look which does always help.

$gap_look .= make_pad($quantum - 
	(cycles($gap_look) + cycles($gap_snd_off) + cycles($gap_tail)));

# We'll have the generator detect "jr" and automatically trigger tail
# construction, label modification and padding.

$found = q{
	dec	e
	ld	a,(de)
	ld	h,a
	ld	l,$80+cmd_off
};

$found_snd_off = $snd_off;
$exx_found_snd_off = $snd_off;
$found_tail = $tail;

# At E = 0 we're working on the last buffered byte.  So we have two cases.
# One is to continue with buffered data which is covered in gap_skip.
# These handlers operate with the standard $snd_off and $tail.
$gap_skip = q{
	dec	e
	jp	z,get
	ld	a,(de)
	ld	h,a
};

# The other case is to get a byte and return to the main loop.

$get = q{
	ld	a,l
	exx
	ld	de,audbuf
	exx
	ld	e,low(audbuf_end)
	ld	l,cmd_off
	in	a,(f_data)
	ld	h,a
};

$get_snd_off = $snd_off;
$exx_get_snd_off = $exx_snd_off;
$get_tail = $tail;

sub addcode {
	my($start, $end) = scalar @bank_src;
	@line = split("\n", expand($_[1]));
	$t{$_[0]} = 0;
	foreach (@line) {
		next if /^\s*$/;
		($b, $t, $m) = asm($_);
		push(@bank_src, $_);
		push(@bank_bin, $b);
		push(@bank_cyc, $t + $m * $m1wait);
		$t{$_[0]} += $t + $m * $m1wait;
	}
	$t{$_[0]} = int($t{$_[0]} + 0.5);
	$end = scalar @bank_src;
	$range{$_[0]} = "$start $end";
}

addcode('snd_off', $snd_off);
addcode('exx_snd_off', $exx_snd_off);
addcode('tail', $tail);

$opwait{'ini'} = $vidwait;
addcode('gfx', $gfx);
$opwait{'ini'} = 0;
addcode('home', $home);
addcode('aud', $aud);

addcode('gap_look', $gap_look);
addcode('gap_snd_off', $gap_snd_off);
addcode('gap_tail', $gap_tail);

addcode('found', $found);
addcode('found_snd_off', $found_snd_off);
addcode('found_tail', $found_tail);

addcode('gap_skip', $gap_skip);
addcode('get', $get);
addcode('get_snd_off', $get_snd_off);
addcode('exx_get_snd_off', $exx_get_snd_off);
addcode('get_tail', $get_tail);

print "; Generated by genplayer.pl\n";
print "; Playback format $format on host $host\n";
print "\tinclude\tblock.inc\n";

cmd(0x5000, 'gfx', 'snd_off', 'tail');
cmd(0x7000, 'home', 'snd_off', 'tail');
cmd(0x9000, 'aud', 'snd_off', 'tail');

cmd(0xb000, 'gap_look', 'gap_snd_off', 'gap_tail');
cmd(0xb080, 'gap_skip', 'snd_off', 'tail');

for ($addr = 0x5000; $addr <= 0xd000; $addr += 0x80) {
	next unless $handler[$addr] ne '';
	printf "\tblock_start\t\$%04x+cmd_off\n", $addr;
	print $handler[$addr];
	print "\tblock_end\n";
}

print "\tinclude\tplayer.inc\n";

sub cmd {
	my($org, $core, $snd, $dispatch) = @_;
	my($i, $r1, $r2);
	my($exx_snd) = $snd;

	if ($t{"exx_$snd"} > 0) {
		$exx_snd = "exx_$snd";
	}

	for ($i = 0; $i < 32; $i++) {
		$handler = '';

		build_pads($quantum - $t{$core} - $t{$dispatch}, $snd);

		$sndtime = $i * ($quantum - $t{$dispatch}) / 32;
		$hit = $sndtime;

		$handler .= "; $hit\n";

		$clock = 0;
		$snd_done = 0;
		$exx = 0;

		$r1 = emit($core, 0);
		$pad = $exx ? 'exx_pad' : 'pad';
		$r2 = emit($pad, 0);
		$hit = 10 * $quantum;
		$handler .= "; at $clock\n";
		emit($exx ? $exx_snd : $snd, 0);
		$snd_done = 1;
		emit($core, $r1);
		emit($pad, $r2);
		emit($dispatch, 0);

		while (@branch) {
			$clock = pop(@branch);
			$no_snd = pop(@branch);
			$num = pop(@branch);
			$label = pop(@branch);
			$label_snd = $label . '_snd_off';
			$label_tail = $label . '_tail';
			$handler .= "$label$num:\n";

			$padcyc = $quantum - $clock - $t{$label} - $t{$label_tail};
			if ($no_snd) {
				build_pads($padcyc, '');
			}
			else {
				build_pads($padcyc, $label_snd);
			}

			$exx = 0;
			$hit = $sndtime;
			$r1 = emit($label, 0);
			$pad = $exx ? 'exx_pad' : 'pad';
			$r2 = emit($pad, 0);
			$hit = 10 * $quantum;
			emit($exx ? "exx_$label_snd" : $label_snd, 0) if !$no_snd;
			emit($label, $r1);
			emit($pad, $r2);
			emit($label_tail, 0);
		}

		# Only skip opcodes need this check, but fairly harmless otherwise.
		$handler .= sprintf "\tassert(\$ < \$%04x+cmd_off)\n", $org + $i * 256 + 0x80;
		$handler .=  ";----\n";

		$handler[$org + $i * 256] = $handler;
	}
}

# Globals
#	$clock - running count of cycles used
#	$hit - stop output at this number of cycles
#	$snd_done - set if sound output has already occurred
#	@branch - extra output required do to jp/jr in code
#	$exx - in portion of code with alternate registers active
# Parameters:
#	name of code fragment
#	start line
# Return;
#	num of lines consumed in fragment

sub emit {
	($i0, $i1) = split(' ', $range{$_[0]});
	$i0 += $_[1];
	$used = 0;
	for (; $i0 < $i1 && $clock + $bank_cyc[$i0] < $hit; $i0++) {
		$clock += $bank_cyc[$i0];
		$branchnum = '';
		$exx = !$exx if $bank_src[$i0] =~ /\bexx\b/;
		if ($bank_src[$i0] =~ /\b(j[rp])\b.*,(\S+)/) {
			$branchnum = ++$seqnum;
			push(@branch, $2, $branchnum, $snd_done,
				$clock + 5 * ($1 eq 'jr'));
		}
		$handler .= "$bank_src[$i0]$branchnum\n";
		$used++;
	}
	return $used;
}

# Change "^N" into N repetitions.
sub expand {
	my($exp) = '';
	foreach (split("\n", $_[0])) {
		$rep = 1;
		if (/^(\d+)/) {
			$rep = $1;
			s/^\d+//;
		}
		$exp .= "$_\n" x $rep;
	}
	return $exp;
}

sub build_pads {
	$padcyc = $_[0] - $t{$_[1]};
	addcode('pad', make_pad($padcyc));
	if ($t{'pad'} != $padcyc) {
		$handler .= ";; ERROR - needed $padcyc padding but got $t{'pad'}\n";
	}

	$padcyc = $_[0] - $t{"exx_$_[1]"};
	addcode('exx_pad', make_pad($padcyc));
	if ($t{'exx_pad'} != $padcyc) {
		$handler .= ";; ERROR - needed $padcyc padding but got $t{'exx_pad'}\n";
	}
}

# Create list of instructions to waste $_[0] cycles.
#
# Nothing fancy and pretty conservative.  Mostly use NOP and deal with
# remainders like so:
#
#	0		nothing to do
#	1		"ld i,a" which drops 9.
#	2		"jp $+3" which drops 10.
#	3		"or a,0" which drops 7.
#
# So we can't handle a lot of cases.  Shortest instructions are put
# first to make padding work better for sound off positioning.
#
# With M1 wait states the handling changes and is even more constrained.

sub make_pad {
	my($cyc) = $_[0];
	my($pad, $ext, $compact) = ('', '', '');
	return '' if $cyc <= 0;

	$t_exsp = 19 + $m1wait;
	$t_nop = 4 + $m1wait;
	$t_min = 7;
	$t_min = 14;
	$t_min = 23 if $m1wait == 2;

	# Be super compact for long delays.  Let the padding have
	# 3 nops minimum.  And don't go below the minimum we can handle.
	if ($cyc > 3 * $t_nop + $t_min + 2 * $t_exsp) {
		$compact = 2 * int(($cyc - (3 * $t_nop + $t_min)) / (2 * $t_exsp));
		$cyc -= $compact * $t_exsp;
		$compact = "\tex\t(sp),hl;\n" x $compact;
	}

	# At two waits the atomic modulo options are not good.
	# Not that fiddling with RET CC helps.
	# %
	# 1    x7  13
	# 2    x8  14
	# 3     9
	# 4   x10  16
	# 5   x11 x17  23

	if ($m1wait == 2) {
		if ($cyc >= 12 && ($cyc % 6) == 1) { $ext = "\tout\t(0),a;\n"; $cyc -= 13; }
		if ($cyc >= 14 && ($cyc % 6) == 2) { $ext = "\tjr\t\$+2;\n"; $cyc -= 14; }
		if ($cyc >=  9 && ($cyc % 6) == 3) { $ext = "\tor\ta,0;\n"; $cyc -= 9; }
		if ($cyc >= 16 && ($cyc % 6) == 4) { $ext = "\tinc\tsp;\n\tdec\tsp;\n"; $cyc -= 16; }
		if ($cyc >= 23 && ($cyc % 6) == 5) { $ext = "\tor\ta,0;\n\tjr\t\$+2;\n"; $cyc -= 23; }
	}
	elsif ($m1wait == 1) {
		if ($cyc >= 11 && ($cyc % 5) == 1) { $ext = "\tld\ti,a;\n"; $cyc -= 11; }
		if ($cyc >= 12 && ($cyc % 5) == 2) { $ext = "\tout\t(0),a;\n"; $cyc -= 12; }
		if ($cyc >=  8 && ($cyc % 5) == 3) { $ext = "\tor\ta,0;\n"; $cyc -= 8; }
		if ($cyc >= 14 && ($cyc % 5) == 4) { $ext = "\tld\t(0),a;\n"; $cyc -= 14; }
	}
	else {
		if ($cyc >= 7) {
			if (($cyc % 4) == 1) { $ext = "\tld\ti,a;\n"; $cyc -= 9; }
			if (($cyc % 4) == 2) { $ext = "\tjp\t\$+3;\n"; $cyc -= 10; }
			if (($cyc % 4) == 3) { $ext = "\tor\ta,0;\n"; $cyc -= 7; }
		}
	}

	$pad = "\tnop;\n" x int($cyc / $t_nop) if $cyc > 0;
	return $pad . $ext . $compact;
}

sub cycles {
	my($b, $t, $m) = asm($_[0]);
	return $t + $m * $m1wait;
}
